"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Folksonomy = void 0;
const openapi_fetch_1 = __importDefault(require("openapi-fetch"));
const formbody_1 = require("./formbody");
const consts_1 = require("./consts");
class Folksonomy {
    constructor(fetch, authToken) {
        this.baseUrl = "https://api.folksonomy.openfoodfacts.org";
        this.authToken = authToken;
        this.fetch = fetch;
        this.raw = (0, openapi_fetch_1.default)({
            baseUrl: this.baseUrl,
            fetch,
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${authToken}`,
                "User-Agent": consts_1.USER_AGENT,
            },
        });
    }
    validateAuthToken(message) {
        if (!this.authToken) {
            throw new Error(message || "Auth token is required to perform this action");
        }
    }
    /**
     * Get the list of keys with statistics
     *
     * The keys list can be restricted to private tags from some owner.
     */
    getKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.raw.GET("/keys");
            return res.response.json();
        });
    }
    /**
     * Get the list of products that have a `key` or `key=value` if `value` is provided
     */
    getProducts(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.raw.GET("/products", {
                params: { query: { k: key, v: value } },
            });
            return res.response.json();
        });
    }
    putTag(tag) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateAuthToken();
            const res = yield this.raw.PUT("/product", { body: tag });
            return res.response.status === 200;
        });
    }
    /**
     * Get a list of existing tags for a product
     */
    getProduct(barcode) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.raw.GET("/product/{product}", {
                params: { path: { product: barcode } },
            });
            return res;
        });
    }
    /**
     * Update a product tag (or add it if it does not exist)
     *
     * @param tag Tag to add or update with the following fields:
     * - `k`: key
     * - `v`: value
     * - `product`: barcode
     * - `version`: version of the tag (must be equal to previous version + 1)
     * - `owner`: user_id of the owner of the tag (empty for public tags)
     *
     * @returns if the tag was added or updated
     */
    addTag(tag) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateAuthToken();
            const res = yield this.raw.POST("/product", {
                body: tag,
            });
            return res.response.status === 200;
        });
    }
    /**
     * Delete a product tag
     *
     * @returns if the tag was deleted
     */
    removeTag(tag) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateAuthToken();
            const res = yield this.raw.DELETE("/product/{product}/{k}", {
                params: {
                    path: { product: tag.product, k: tag.k },
                    query: { version: tag.version },
                },
            });
            return res;
        });
    }
    /**
     * Authentication: provide user/password and get a bearer token in return
     *
     * @param username Open Food Facts user_id (not email)
     * @param password user password
     * @returns the bearer token, to be used in later requests with usual "Authorization: bearer token" headers
     */
    login(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.raw.POST("/auth", {
                body: { username, password },
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                bodySerializer: formbody_1.formBody,
            });
            if (res.response.status !== 200) {
                return {
                    error: {
                        detail: [
                            {
                                msg: "Status code " + res.response.status,
                                type: "error",
                                loc: [],
                            },
                        ],
                    },
                };
            }
            else if (res.error != null) {
                return { error: res.error };
            }
            const token = (yield res.response.json());
            return { token };
        });
    }
}
exports.Folksonomy = Folksonomy;
